# chapter1

一个用来渲染图像的OpenGL程序需要执行的主要操作如下所示：

 - 从OpenGL的几何图元中设置数据，用于构建形状
 - 使用不同的着色器shader对输入的图元数据执行计算操作，判断它们的位置，颜色以及其他渲染属性
 - 将输入图元的数学描述转换为与屏幕位置对应的像素片元fragment,也称作光栅化rasterization
 - 针对光栅化过程产生的每个片元，执行片元着色器fragment shader从而决定这个片元的最终颜色和位置
 - 如果有必要，还需要对每个片元执行一些额外的操作，例如判断片元对应的对象是否可见，或者将片元的颜色与当前屏幕位置的颜色进行融合。


OpenGL是使用客户端-服务端的形式实现的，我们编写的应用程序可以看作客户端，而计算机图形硬件厂商所提供的OpenGL实现可以看作服务端。
OpenGL的某些实现（eg X窗口系统的实现）允许服务端和客户端在一个网络内的不同计算机上运行。
这种情况下，客户端负责提交OpenGL命令这些OpenGL命令然后被转化为窗口系统相关的协议，通过共享网络传输到服务端，最终执行并产生图像内容。


所有OpenGL程序的基本结构通常都是类似的，其步骤如下：

 - 初始化物体渲染所对应的状态
 - 设置需要渲染的物体

**Render渲染**:表示计算机从模型创建最终图像的过程。OpenGL是基于光栅化的系统但是也有别的方法用于生成图像，例如光线追踪ray tracing。就算是用到了光线追踪技术的系统，同样有可能需要用到OpenGL来显示图像，或者计算图像生成所需的信息。

**model模型/场景对象**:通过几何图元，例如点，线和三角形来构建的，而图元与模型的顶点vertex也存在着各种对应的关系

**shader着色器**:是图形硬件设备所执行的一类特殊函数，可以看做专为GPU编译的一种小型程序。在OpenGL中，会用到四种不同的着色阶段shader stage其中最常用的包括顶点着色器vertex shader以及片元着色器。

**pixel像素**:显示器上最小的可见单元。计算机系统将所有的像素保存到帧缓存framebuffer当中，后者是由图形硬件设备管理的一块独立内存区域，可以直接映射到最终的显示设备上。




 
 
